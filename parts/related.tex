% Related Work(0.5p)
% \section{Related Work}
% \label{sec:related}

In this chapter, we highlight the most closely related work.

% Other approaches for context-aware systems threat context-requirements as a tupla (context, requirement)\cite{knauss_acon:_2016}. These approaches handle the runtime of a context-requirements. When the context is valid the requirements apply. In this work, we handle the deployment view. Therefore, we need a different view: if the context is possible, the requirement should be satisfiable.



% In the literature, there are proposals that tackle the problem of handling changes at system context~\cite{knauss_acon:_2016}. These proposals focus on the system external context, reasoning about known facts about the external managed world and how it affects the systems goals.

\section{Goal Oriented Approaches}
Angelopoulos et al.~\cite{angelopoulos_capturing_2015} present an approach to handle  variability at three different dimensions: goals, behavior, and architecture. Variability can occur at goals dimension as an OR-refinement or context selection; at behavior dimension as different plans flows; and at the architecture dimension with the variability of components and implementations. However, their approach does not handle variability at deployment.

% Must of these approaches ignores variability in the computing environment, the underline computing resources that form the infrastructure for executing the system software. None of them solve the problem of software development for a highly variable environment from different software providers.
% Our approach focus on how move components to target environment.

Ali et~al.\cite{ali_requirements-driven_2014} explore the optimization of the deployment for a given context variability space in which the system will be deployed. Contextual Goal Model (CGM) was used to represent aspects of the environment related to the solution space, which was to be analyzed at design-time. This analysis at design-time can be used to evaluate which alternative strategy to implement.
It differs from our work in which we explore the context of the computing environment, not the solution space. Our approach allows for, at deployment time, choosing  between components already available. Both approaches could be used in tandem, as both rely on CGM but provide complementary kinds of analyses.

\section{Automatic Deployment Approaches}
Researchers have investigated Dynamic Software Product Line (DSPL) a way of adapt for variations in users requirements and system environments.
 DSPLs extend the concept of conventional Software Product Lines (SPLs) by enabling software-variant generation at runtime. In classic SPL, products can be derived from a SPL infrastructure for a specific customer individual or customer segment, in the assumption that the requirements for that customer and the execution environment will not change. In DSPLs a product can change to another configuration, in runtime, in response to a context change. To make it possible the feature model should be available at runtime.\cite{bencomo_view_2012}

Bencomo et al.~\cite{bencomo_dynamically_2008} use a SPL approach to adaptation. It  associates an architecture variability model with an environment variability model. The environment variability is modeled as a transition system. The structural variability is responsible for the system adaptation. A configuration or a product is a set of selected components. A configuration is associated with states in the environment variability model. Unlike our approach, their focus is on the adaptation in the configuration at runtime but not on the deployment itself. Mizouni et al. \citep{mizouni_framework_2014} use a feature model associated with context requirements.

Leite et al.~\cite{ferreira_leite_user_2014} propose an approach for automatic deployment on inter-cloud environments. It relies on abstract and concrete features models and constraint satisfaction problem solver to create a computing environment using resources distributed across various clouds.
It integrates a self-healing schema for cloud deployment based on which virtual machines in the cloud are monitored and in the case of failure the machine can be
restarted or terminated and then a new one created.
The approach is specific to cloud environments and requires instantiating at design-time a model knowledgeable about the environment.
It also strongly depends on design-time created scripts to realize the deployment of an application, which limits the autonomy of the approach, especially in unknown environments.

Gunalp et al.~\citep{gunalp_rondo_2015} presents an approach for automatic deployment, in which the deployment specialist specifies the system deployment in terms of resources and desired target states of such resources. The approach follows preset strategies to keep the managed software resources in the specified states. They use a low-level model to drive the adaptation: implemented strategies to move watched resources to target states. Differently, our approach uses a goal model which is a more abstract model. %They differ from our approach in the sense that we focus/promote/propose/support/enhance/.


\section{Package managers}
Package managers, such as Debian package manager\cite{aoki_debian_2016}, are capable of solving dependencies and deploying software, however, their approach to heterogeneity is limited. In Debian package manager, the heterogeneity is handled for processor architecture and version of operating system. There are separated repositories for each specification of architecture and operating system. The users' machines have only repositories registered with compatible repositories.
In our approach, separated repositories are not required, context conditions are evaluated for each artifact instead.
Another difference is in how dependencies are declared. They require that a managed application declare their dependencies by name and version. In our approach, differently, the dependencies are declared in terms of interfaces for which implementations are required, not specific implementations. For example, in our case study, for advisor root strategy we create an artifact that declares \emph{Get Position} as a requirement, but not a specific artifact is required. Any artifact that provides \emph{Get Position} would satisfy the requirement. This requirement declaration, in terms of interface, associated with context conditions allow
for a more flexible dependency resolution at deployment-time.

\begin{table*}[!ht]
\centering
\caption{Comparing characteristic properties of selected approaches related to Goalp}
\label{table_related_works}
\begin{tabular}{p{4cm} ccc}
\toprule
Work by &
   Goal Oriented &
    Handle Heterogeneity &
    Autonomic Deployment \\
\midrule
Ali et al.\citep{ali_requirements-driven_2014} & \cellcolor{blue!10} Yes & No & No \\
Angelopoulos et al. \cite{angelopoulos_capturing_2015} & \cellcolor{blue!10}Yes & No & No \\
Mizouni et al. \citep{mizouni_framework_2014} & No & \cellcolor{blue!10} Yes & No \\
Leite et al. \citep{ferreira_leite_user_2014}  & No & \cellcolor{blue!10} Yes & No \\
Gunalp et al.\citep{gunalp_rondo_2015} & No & \cellcolor{blue!10} Yes  &  No\\
Goalp & \cellcolor{blue!10} Yes & \cellcolor{blue!10} Yes & \cellcolor{blue!10} Yes \\
\bottomrule
\end{tabular}
\end{table*}

Table~\ref{table_related_works} summarizes work most related to Goalp. Ali et al.\citep{ali_requirements-driven_2014} and Angelopoulos et al. \cite{angelopoulos_capturing_2015} works are both goal-oriented works that handle variability at the design of a system, however, they do not handle heterogeneity in the computing environment and has no support adaptation in the deployment time. Mizouni et al. \citep{mizouni_framework_2014}, Leite et al. \citep{ferreira_leite_user_2014} and Gunalp et al.\citep{gunalp_rondo_2015} works' handle some kind of adaptation at deployment time but uses a low-level model to drive the adaptation which requires a knowledge about the computing environment at design-time.


% While package mangers such as aptitude and RPM can get components and handle some variabilities, e.g CPU architecture, they are not adaptive, so they not handle changes in the computing environment at runtime. They favor reuse at a library level. We propose reuse at component level.
