\section{Software Components}
Heineman define \emph{software component} as a
\say{software element that conforms to a component model and can be independently deployed and composed without modification according to a composition standard}\cite{heineman_component-based_2001}.

Software components is a unit of composition. Software systems are build by composing different components.  Software components must conform to a component model by having contractually specified interfaces and explicit context dependencies only.\cite{szyperski_component_2002}.

Component based software engineering (CBSE) approach consists in building systems from components as reusable units and keeping component development separate from system development\cite{crnkovic_software_2011}.

A \emph{component	interface} \say{defines a set of component functional properties, that is, a set of actions that’s understood by both the interface provider (the component) and user (other components, or other software that interacts with the provider)}\cite{crnkovic_software_2011}.
A component interface has a role as a component specification and also a means for interaction between the component and its environment.
A \emph{component model} is a set of standards for a component implementation. These standards can standardize naming, interoperability, customization, composition, evolution and deployment.\cite{heineman_component-based_2001}
The \emph{component deployment} is the process that enables component integration into the system. A deployed component is registered in the system and ready to provide services\cite{crnkovic_software_2011}.
\emph{Component binding} is the process that connects different components through their interfaces and interaction channels.

Software architecture deals with the definition of components, their external behavior, and how they interact\cite{kaur_component_2010}. The architectural view of a software can be formalized via an architecture description language (ADL)\cite{medvidovic_classification_2000}.


Component based software engineering (CBSE) approach consists in building systems from components as reusable units and keeping component development separate from system development\cite{crnkovic_software_2011}.

CBSE is built on the following four principles\cite{crnkovic_software_2011}:
\begin{itemize}
  \item \emph{Reusability}. Components, developed once, have the potential for reuse many times in different applications.
  \item \emph{Substitutability}. Systems maintain correctness even when one component replaces another.
  \item \emph{Extensibility}. Extensibility aims to support evolution by adding new components or evolving existing ones to extend the system’s functionality.
  \item \emph{Composability}. System should supports the composition of functional properties (component binding). Composition of extra functional properties, for example composition of components’ reliability, is another possible form of composition.
\end{itemize}

\subsection{Component-Based Adaptation}

In the literature was proposed frameworks for architecture and components based adaptation.

Rainbow\cite{garlan_rainbow:_2004} is a framework for self-adaptation architecture based. It keeps an model of the architecture of the system and can be extended with rules to analysis the system behavior at runtime, find adaptation strategies and perform this changes. It separate the functional code (internal mechanisms) from adaptation code (external mechanism) in a schema called external control, influenced by control theory.

MUSIC\cite{rouvoy_music:_2009} project provides a component-based middleware for adaptation that propose to separate the self-adaptation from business logic and delegate adaptation logic to generic middleware. As in our propose it adapts by evaluating in runtime the utility of alternatives, to chose a feasible one (e.g., the one evaluated as with highest utility).

Flashmob~\cite{sykes_flashmob:_2011} is an approach for distributed self-assembly. Different from MUSIC and Rainbow, it handles component-based adaptation in a distributed environment. The self-assembly can be described as: given a set of available components (with various functional and non-functional properties), and a configuration of components which are already running, find a new configuration which works (better) in the changed execution environment (including hardware),
meets new user requirements or takes account of new component implementations~\cite{sykes_flashmob:_2011}. Flashmod uses a three-layer model: goals, management and components proposed by Kramer and Magee~\cite{kramer_self-managed_2007}, extending it to allow distributed agreement in a given configuration.

OSGi\cite{the_osgi_alliance_osgi_2007} is a Java centric platform that allows dynamic bind and unbind of components, usually named bundles. Ferreira et al.\cite{ferreira_-osgi:_2012} proposed a framework for adaptation based on OSGi.

\subsection{From Goals to Components}

Lamsweerde \cite{van_lamsweerde_system_2003} present a method for derive architecture from KAOS goal model. First an abstract draft is generated from functional goals. Secondly, the architecture is refined to meet non-functional requirements such as cohesion.

% Penserini \citep{penserini_design_2007} propose a method for generate agents from goal models.
% Morandini \cite{morandini_towards_2008}
% Tropos - Jadex-BDI}
Pimentel et al. \cite{pimentel_deriving_2012} present a method  using i* models to produce architectural models in Acme. If focus in he development of adaptive systems. First, it transforms a i* model into a modular i* model by means of horizontal transformation. Secondly, it creates an architecture model from the i* modularized model by means of vertical transformation. Architectural design models is made easier by the
presence of actor and dependency concepts.

Yu et al.~\cite{yu_goals_2008} proposed an approach for keep the variability that exists in the goal model into the architecture.
It present a method for creating a component-connector view from a goal model.
A preliminary component-connector view is generated from a goal model by creating an interface type for each goal. The interface name is directed derived from the goal name. Goals refinements result in implementation of components.
If a goal is And-decomposed, the component has as many \emph{requires} interfaces as subgoals.

\begin{lstlisting}
Component G {
  provides IG;
  requires IG1, IG2;
}
\end{lstlisting}

If the goal is OR-decomposed, the interface type of subgoals are the interface type of the parent goal.
%It's the most important patterns as it allow variability at architecture.

\begin{lstlisting}
Component G1 {
  provides IG;
}

Component G2 {
  provides IG;
}
\end{lstlisting}

A component equivalent to the parent goal is generated with a switch.


%TODO Input and outputs are added to the interface.

%TODO Related lower level components can be merged by parametrization.
