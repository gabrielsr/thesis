 
 
 
 
 imagens/  
A Goal-Oriented Middleware for Dependable Self-Adaptive Systems
[a][a] [a] Genaina Nunes RodriguesCIC/UnB
[a][a] [a] Alba Cristina Magalhaes Alves de MeloCIC/UnB
9Junho2016
CIC/UnB
CIC/UnB
Gabriel SiqueiraRodrigues
004.4
dependabilidade
dependability
american
In recent years, we see a growing availability of devices with computer capabilities. Along with this advent, comes out an opportunity to develop and deploy applications that explore those devices in dynamic environments. However, such environments are inherently characterized by uncertainty, in particular from the perspective of the system designer. To design dependable solutions for environments with a high level of uncertainty, we need models at runtime to represent the system structure, requirements as well as the system's contexts of operation in an integrated way. In addition, we need methods to reason about the system levels of operation and change them at runtime, whenever needed. In this work, we propose to address those issues by devising a component-based model approach for self-adaptation relying on GORE (goal-oriented requirements engineering) and a component-based architecture model. By these means, we plan to develop a middleware that follows and implements that model. Last, but not least, the middleware we will provide fault tolerance strategies to build a foundation for dependable systems.
  
  
  
Introduction
With increasing popularity of mobile computation and wireless networks we have seen the rise of  interest in new domains of computation that uses the capacity of heterogeneous computer units in a given location.
Example of such domains are Ubiquitous Computing , Internet of Things (IoT), Assisted Living and Opportunistic Computing. In such domains, the computing environment can greatly vary from place to place.
Solutions for these domains would benefit if they could plan the deployment of the system for a given computing environment at runtime.
 Salehie at al.  define self-adaptive software as one that adjust artifacts or attributes in response to changes in the self and in the context of a software system.
self being the whole body of software. And context being everything in the operating environment that affects the system's properties and its behavior.
Architecture-based (or component-based) self-adaptive approaches adapt the systems by acting on components of the system or by replacing them. A possible solution for development of applications for environment with a high level of uncertainty would be to choose an architecture at runtime for the given environment, distributing software components between available computational units and setting up the right communication channels. But to make it possible we need also a model of the system so we can reason about possible system structures in face of the system requirements and context.
So it is important to trace system components back to requirements.
Goal Oriented Requirements Engineering (GORE) approaches have gained special attention as a technique to specify self-adaptative systems.
Goals capture, the various objectives the system under consideration should achieve.
A multi-agent system (MAS) is a distributed computing system with autonomous interacting intelligent agents that coordinate their actions so as to achieve its goals.
Autonomous software agents provide a promising solution to the needs of decentralized networked systems, able to adapt their behaviour in a complex and dynamically changing environment .
Dalpiaz et al. proposed Runtime Goal Models to reason about runtime fulfillment of goals.
Goal models allow us to reason about the requirements of the system and its execution context, however lacks a structural view of the system to be. On the other hand, component-based software engineering (CBSE) explicitly addresses the system structure. To the best of our knowledge there is no integrated model to reason about the system structure in relation to its contexts and requirements.
In addition, we need methods to reason about the system levels of operation and change them at runtime, whenever needed. In this work, we propose to address those issues by devising a component-based model approach for self-adaptation relying on GORE (goal-oriented requirements engineering) and a component-based architecture model.
Such model would allow us to built more dependable systems. For example, we could choose to use fault tolerance techniques to more critical tasks of the system.
 In this work we will explore the integration of approaches to allow reasoning about the relationship between the system goals, components and context of execution.
 The objective is be able to create valid deployment configurations, trace the system goals accomplishment at runtime and use fault tolerance techniques to improve the dependability of the system in face of error prone components.
In order to allow the system make decisions about its structure based on requirements and context we need a model that can correlate these three concepts: the system structure, the goals and the execution context.
    
        Research Question 1 (RQ1): What would be a good model of software system that
        could allow one to reason about the system structure, context and trace the goals at runtime? In other words, how to represent the system goals, architectural structure, operation context and their relationship?
    
Previous work in the literature  have partially tackled this research question. However, our major concern here relates to the traceability between goals and tasks, software architectural components and the context of operation.
To develop what would be a good model we address further questions in relation to the fitness of the model for the purpose of deciding on system adaptations. First of all, we want to realize a valid deployment of the system:
    
        Research Question 2 (RQ2): How to, using the model from RQ1, deploy a Self-Adaptive System that is dependable in face of context variability? 
    
Beside checking the system validity in other to predict system dependability, we want to be able to tolerate faults at runtime. This leads us to the next research question:
    
        Research Question 3 (RQ3): How to guarantee that the systems is dependable in face of error prone components at runtime?
        
    
General Objectives
  propose, implement and validate a model to reason about and adapt systems based on its adaptation goals, structure and context.
Specific Objectives
  propose a conceptual model for component-based runtime goal-model system
  implement and validate a middleware for component-based runtime goal model
  
  
  release the middleware as a comprehensible open source project
  implement and validate runtime strategies for dependability in the proposed platform
Background
Dependability
Dependability can be defined as the ability of a system to avoid faults in its services
that (1) are more frequent or (2) more severe than acceptable. Or as the characteristic of a system to be justifiably trusted.
A common terminology used for system deviations is the following: 
  failure: (or service failure) is a perceived deviation from the correct service provided by a system.
  error: is a deviation of correct internal system state that can lead to its subsequent failure.
  fault: is the adjudged or
hypothesized cause of an error
Dependability includes the following attributes:
  availability: readiness for correct service.
  reliability: continuity of correct service.
  safety: absence of catastrophic consequences on the
user(s) and the environment.
  integrity: absence of improper system alterations.
  maintainability: ability to undergo modifications and repairs.
Many means have been developed of how to attain the attributes of dependability. These means can be classified as:
  Fault prevention means to prevent the occurrence or introduction of faults.
  Fault tolerance means to avoid service failures in the presence of faults.
  Fault removal means to reduce the number and severity of faults.
  Fault forecasting means to estimate the present number, the future incidence, and the likely consequences of faults.
Attain Dependability at Runtime 
To keep dependability in face of uncertainty in the deployment environment some techniques have been proposed for runtime analysis at runtime.
Felipe et al propose a method of fault-tolerance for a scientific workflow execution in grid.
Alessandro Leite  propose a fault tolerance schema for cloud deployment based on which a fault instance in the cloud is monitored and in case of failure the instance can be restarted or terminated and them a new instance created.
Danilo et al propose a methodology for fault forecasting by which developer, at design time, annotate the goal decomposition in goal model and specify context variables. A special tool generate a formula for, given a context, evaluate the probability of achieve a goal at runtime.
 
Self-Adaptive Systems
Self-adaptive systems have been accepted as a promising approach to tackle context change. Self-adaptivesses is an approach in which the system
"evaluates its own behavior and changes behavior when the evaluation indicates that it is not accomplishing what the software is intended to do, or when better functionality or performance is possible.".
Self-adaptive software aims to adjust various artifacts or attributes in response to changes in the self and in the context of a software system.
A key concept in self-adaptive systems is the awareness of the system. It has two aspects:
   self-awareness means a system is aware of its own states and behaviors.
   context-awareness means that the system is aware of its context,
Schilit et al. define context as the sufficiently exact characterization of the situations of a system by means of perceivable information that is relevant for the adaptation of the system
Schilit et al. define context adaptation as a system’s capability of gathering information about the domain it shares an interface with, evaluating this information and changing its observable behavior according to the current situation.
Software Components and Architecture
Heineman define software component as a
software element that conforms to a component model and can be independently deployed and composed without modification according to a composition standard.
Software components is a unit of composition. Software systems are build by composing different components.  Software components must conform to a component model by having contractually specified interfaces and explicit context dependencies only..
A component	interface defines a set of component functional properties, that is, a set of actions that’s understood by both the interface provider (the component) and user (other components, or other software that interacts with the provider).
A component interface has a role as a component specification and also a means for interaction between the component and its environment.
A component model is a set of standards for a component implementation. These standards can standardize naming, interoperability, customization, composition, evolution and deployment.
The component deployment is the process that enables component integration into the system. A deployed component is registered in the system and ready to provide services .
Component Binding is the process that connects different components through their interfaces and interaction channels.
Software architecture deals with the definition of components, their external behavior, and how they interact.
Component based software engineering (CBSE) approach consists in building systems from components as reusable units and keeping component development separate from system development.
CBSE is built on the following four principles:
  Reusability. Components, developed once, have the potential for reuse many times in different applications.
  Substitutability. Systems maintain correctness even when one component replaces another.
  Extensibility. Extensibility aims to support evolution by adding new components or evolving existing ones to extend the system’s functionality.
  Composability. System should supports the composition of functional properties (component binding). Composition of extra functional properties, for example composition of components’ reliability, is another possible form of composition.
Goal
Goal-oriented requirements engineering (GORE) is concerned with the use of goals for eliciting, elaborating, structuring, specifying, analyzing, negotiating, documenting, and modifying requirements.
GORE models are the tool used by system analysts and stakeholders to reason about the system requirements. Goal modeling represents a shift in relation to traditional software development approaches as it focus on stakeholder goals and states that the system needs to achieve and not in how it achieves it.
Concepts
A goal is an objective the system under consideration should achieve. 
Proposal
Proposed Solution
We propose a component model for goal oriented multi-agent systems and a runtime model as a solution for couple with computing environment uncertainty.
This model will be implemented by a middleware, that will keep the traceability between goals and architecture and allow for managing the architecture.
In addition we pretend to implementing fault-tolerance techniques as reusable components.
Conceptual Model
Component Model
In conceptual model an agent is an independent computational unit that manages its own resources (CPU, memory, disk, sensors, etc).
We add to Tropos Model the concept of strategy.
The strategy is a alternative way of achieving a goal (as in GORE) and a component in the architecture. Each goal correspond to a component. Each OR decomposition in the DGM should correspond to a additional component.
Plans are implemented by code in the strategy component.
By this we aim at creating an appropriate abstraction to allow composable architecture while keeping the traceability between the requirements and implementation at runtime.
An agent in the system has a repository of strategies that had all its runnable code. The agent have a model of that repository that it can use for reason about its capacities and plans. The agent can also insert and remove plans from its repository.
  Capability: description of a kind of goal that an agent can perform. Its an interface description in the architecture. (e.g SUM a and b)
  Strategy:
  Plan: a plan is a Capability alternative implementation (e.g (SUM,a,b) => a+b). Its also a module in the architecture.
  Plan Repository: repository of know plans
Strategy Selection
To allow component based adaptation we propose a mechanist of strategy selection at runtime.
For a hight level of flexibility we propose that the selection mechanism in itself should be developed as components in the architecture.
At a low level an agent has the capability of fulfill goals. Inspired by component based frameworks like Rainbow we propose that the strategy to fulfill a goal should be chosen by means of a utility function. That utility function should be responsible to calculate which available strategy will have a better contribution for softgoals.
The capacity and strategy should be as follows:
<Fulfill Goals> Goal the capability of fulfill generic goals.
<Fulfill Goals> Strategy  strategy to fulfill goals by selecting available strategies and evaluating them with an utility function. Consist of 3 sub-goals:
  
    Find Matching Strategies
    Decide on Strategies
    Deploy the Selected Strategy
  
And the following three strategies implement the previous 3 goals.
  <Find Local Matching Strategies> Strategy accomplish <Find Matching Strategies>
  return the list of matching strategies. A matching strategy is any strategy that implement the goal interface.
  <Select a Strategy> Strategy accomplish <Decide on Strategies>
  use a pre-configured utility function that analyses strategies metadata and select a strategy.
  <Deploy Strategy> Strategy accomplish <Deploy the Selected Strategy>.
  Consist in deploying the chosen component.
Runtime Model
Dalpiaz et al.  argue that traditional goal models are not enough for reason about the system at runtime. They  propose a distinction between Desgin-time Goal Model and Runtime Goal Model. We extend their proposal with model at runtime of the agent.
Goal Instance: an actual instance of an objective for a given data set. (e.g SUM 2 and 3)
Believe: in the knowledge of an actor about itself and the context.
In the proposed model an actor achieve a goal by deploying a plan. For instance the deployment of plan is a capability itself, as follows:
Awareness
Self-awareness is provided by a set of self-awareness strategies. Example of self-aware strategies are:
  <List Local Strategies> Strategy How the agent can know it actual capabilities.
  <List Goal Instances> Strategy How the agent can know it current intentions.
  <List Deployed Strategies> Strategy How the agent can know it current running strategies.
Related Work
Rainbow is a framework for self-adaptation architecture based. It keeps an model of the architecture of the system and can be extended with rules to analysis the system behavior at runtime, find adaptation strategies and perform this changes. It separate the functional code (internal mechanisms) from adaptation code (external mechanism) in a schema called external control, influenced by control theory. 
Different from our proposal it isn't goal-oriented an there is no work on how to relate Rainbow components to requirements.
MUSIC project provides a component-based middleware for adaptation that propose to separate the self-adaptation from business logic and delegate adaptation logic to generic middleware. As in our propose it adapts by evaluating in runtime the utility of alternatives, to chose a feasible one (e.g., the one evaluated as with highest utility). As Rainbow, MUSIC is not goal-oriented.
Salehie et al.  propose a run-time goal model and its related
action selection. It models adaptable software as a system that exposes sensors and effectors and  proposes a model consisting in Goals, Attributes and Action for selecting actions that will effect the adaptable software at runtime, giving sensed attributes.
So the adaptation mechanism is to choose the best action given the actual attributes.
As this work it uses explicit runtime goals and make them visible and traceable.
Different from it we use a more symmetric approach that can allow for functional
and adaptation management.
Günalp et al.  propose a middleware for pervasive software with autonomic capabilities. The approach is service based. It proposes a component written in a custom language and the use of components repository that allows the discovery on new sensors. The system present a support for adaptability by using policies.
Methodology
In this section we will describe our methodology. At a hight level our main activities will be: review the literature, elaborate a conceptual model, implement and evaluate a middleware, write the dissertation, write paper and viva presentation.
The implementation will be divided in 2 phases so we can submit intermediate results to scientific conferences.



literature review

First we will conduct a literature review with the objective to find all the relevant related works, what is the state of the art, review that works and better proposition our proposal in relation to that works.

elaborate a conceptual model and architecture

In parallel to the literature review, we will develop a conceptual model to integrate Goal-Oriented Requirements Engineering, Architecture-Based Self-Adaptation so that the system goals can be traced to architecture modules at runtime. This conceptual-model will describe the Architectural components of the proposed architecture, their relations, how this elements are related to the goal model that they implement and how this model can be manipulated at runtime.


implement and validate a middleware (Core)

At this stage we will implement the core of a middleware to support execution of components as described by the proposed conceptual model and evaluate. To do the evaluation we will specify and describe a study case system and implement the system using the middleware and the proposed architecture.

write paper about the middleware (Core)

We will report the results of the middleware implementation and validation as a paper.




 

implement and validate dependability strategies

 implement and evaluate GODA strategy for runtime dependability analysis at runtime.

 write paper about dependability strategies

 We will report the results of the middleware implementation and validation as a paper.

write up dissertation

gather all intermediate results and format as a dissertation.

viva

present the dissertation.


Expected Results
Expected Results
With this work we expect to:
Collaborate to self-adaptation corpus of knowledge by contributing with a conceptual model that maps concepts of Goal-Model and Architecture-based adaptation.
Generate a proposal of architecture and reference middleware for development of applications that face a high level of context variation and couple this uncertainty by reasoning about its goal model at runtime.
By the former two items, we expect to allow for future development of more flexible and dependable and adaptable software system.
Chronogram
The proposed work is composed of the following activities:


literature review
elaborate a conceptual model
implement and validate a middleware (Core)
write paper about the middleware (Core)
implement and validate dependability strategies
 write paper about dependability strategies
write up dissertation
viva





plain
