 
 
 
 
 imagens/  
[a][a] [a] Genaina Nunes RodriguesCIC/UnB
<<<<<<< HEAD
25Setembro2015
Gabriel Siqueira Rodrigues
A Goal-Oriented Middleware for Dependable Self-Adaptive Systems
=======
[a][a] [a] Alba Cristina Magalhaes Alves de MeloCIC/UnB
25Setembro2015
Gabriel SiqueiraRodrigues
<<<<<<< HEAD
>>>>>>> feature/review_9
=======
>>>>>>> feature/review_9
Introduction
In the last decade we have seen advances in the study of autonomic computing systems as an alternative to handle the crescent complexity of systems. The complexity in systems come with the need to execute in heterogeneous platforms, to run in multiple environments and handle multiple operation contexts.
With increasing popularity of mobile computation and wireless networks we have seen the rise of  interest in new domains of computation that uses the capacity of heterogeneous computer units in a given location.
Example of such domains are Ubiquitous Computing , Internet of Things (IoT), Assisted Living and Opportunistic Computing. In such domains, the computing environment can greatly vary from place to place.
Solutions for these domains would benefit if they could plan the deployment of the system for a given computing environment at runtime.
 Salehie at al.  define self-adaptive software as one that adjust artifacts or attributes in response to changes in the self and in the context of a software system.
Self being the whole body of software. And context being everything in the operating environment that affects the system's properties and its behavior.
Architecture-based (or component-based) self-adaptive approaches to implement self-adaptive systems adapt the systems by acting on components of the system or by replacing them. A possible solution for development of applications for environment with a high level of uncertainty would be to choose an architecture at runtime for the given environment, distributing software components between available computational units and setting up the right communication channels. But to make it possible we need also a model of the system so we can reason about possible system structures in face of the system requirements and context.
So it is important to trace system components back to requirements.
Goal Oriented Requirements Engineering (GORE) approaches have gained special attention as a technique to specify self-adaptative systems.
Goals capture, the various objectives the system under consideration should achieve.
A multi-agent system (MAS) is a distributed computing system with autonomous interacting intelligent agents that coordinate their actions so as to achieve its goals.
Autonomous software agents provide a promising solution to the needs of decentralized networked systems, able to adapt their behaviour in a complex and dynamically changing environment .
Dalpiaz et al. proposed Runtime Goal Models to reason about runtime fulfillment of goals.
Goal models allow us to reason about the requirements of the system and its execution context, however lacks a structural view of the system to be. On the other hand, component-based software engineering (CBSE) explicitly addresses the system structure. To the best of our knowledge there is no integrated model to reason about the system structure in relation to its contexts and requirements.
In addition, we need methods to reason about the system levels of operation and change them at runtime, whenever needed. In this work, we propose to address those issues by devising a component-based model approach for self-adaptation relying on GORE (goal-oriented requirements engineering) and a component-based architecture model.
Such model would allow us to built more dependable systems. For example, we could choose to use fault tolerance techniques to more critical tasks of the system.
 In this work we will explore the integration of approaches to allow reasoning about the relationship between the system goals, components and context of execution.
 
 The objective is be able to create valid deployment configurations, trace the system goals accomplishment at runtime and use fault tolerance techniques to improve the dependability of the system in face of error prone components.
In order to allow the system make decisions about its structure based on requirements and context we need a model that can correlate these three concepts: the system structure, the goals and the execution context.
    
        Research Question 1 (RQ1): What would be a good model of software system that
        could allow one to reason about the system structure, context and trace the goals at runtime? In other words, how to represent the system goals, architectural structure, operation context and their relationship?
    
Previous work in the literature  have partially tackled this research question. However, our major concern here relates to the traceability between goals and tasks, software architectural components and the context of operation.
To develop what would be a good model we address further questions in relation to the fitness of the model for the purpose of deciding on system adaptations. First of all, we want to realize a valid deployment of the system:
    
        Research Question 2 (RQ2): How to, using the model from RQ1, deploy a Self-Adaptive System that is dependable in face of context variability? 
    
Beside checking the system validity in other to predict system dependability, we want to be able to tolerate faults at runtime. This leads us to the next research question:
    
        Research Question 3 (RQ3): How to guarantee that the systems is dependable in face of error prone components at runtime?
        
    
General Objectives
  propose, implement and validate a model to reason about and adapt systems based on its adaptation goals, structure and context.
Specific Objectives
  propose a conceptual model for component-based runtime goal-model system
  implement and validate a middleware for component-based runtime goal model
  
  
  release the middleware as a comprehensible open source project
  implement and validate runtime strategies for dependability in the proposed platform
Background
Dependability
Dependability can be defined as the ability of a system to avoid faults in its services
that (1) are more frequent or (2) more severe than acceptable. Or as the characteristic of a system to be justifiably trusted.
A common terminology used for system deviations is the following: 
  failure: (or service failure) is a perceived deviation from the correct service provided by a system.
  error: is a deviation of correct internal system state that can lead to its subsequent failure.
  fault: is the adjudged or
hypothesized cause of an error
Dependability includes the following attributes:
  availability: readiness for correct service.
  reliability: continuity of correct service.
  safety: absence of catastrophic consequences on the
user(s) and the environment.
  integrity: absence of improper system alterations.
  maintainability: ability to undergo modifications and repairs.
Many means have been developed of how to attain the attributes of dependability. These means can be classified as:
  Fault prevention means to prevent the occurrence or introduction of faults.
  Fault tolerance means to avoid service failures in the presence of faults.
  Fault removal means to reduce the number and severity of faults.
  Fault forecasting means to estimate the present number, the future incidence, and the likely consequences of faults.
Resilient systems  are expected to continuously provide justifiably be trusted services despite changes coming from the environment or from their specifications.
Attain Dependability at Runtime 
To keep dependability in face of uncertainty in the deployment environment some techniques have been proposed for runtime analysis at runtime.
Felipe et al propose a method of fault-tolerance for a scientific workflow execution in grid.
Alessandro Leite  propose a fault tolerance schema for cloud deployment based on which a fault instance in the cloud is monitored and in case of failure the instance can be restarted or terminated and them a new instance created.
Danilo et al propose a methodology for fault forecasting by which developer, at design time, annotate the goal decomposition in goal model and specify context variables. A special tool generate a formula for, given a context, evaluate the probability of achieve a goal at runtime.
 
Self-Adaptive Systems
Self-adaptive systems have been accepted as a promising approach to tackle context change. Self-adaptivesses is an approach in which the system
"evaluates its own behavior and changes behavior when the evaluation indicates that it is not accomplishing what the software is intended to do, or when better functionality or performance is possible.".
Self-adaptive software aims to adjust various artifacts or attributes in response to changes in the self and in the context of a software system.
A key concept in self-adaptive systems is the awareness of the system. It has two aspects:
   self-awareness means a system is aware of its own states and behaviors.
   context-awareness means that the system is aware of its context,
Schilit et al. define context as the sufficiently exact characterization of the situations of a system by means of perceivable information that is relevant for the adaptation of the system.
Schilit et al. define context adaptation as a system’s capability of gathering information about the domain it shares an interface with, evaluating this information and changing its observable behavior according to the current situation.
Software Components and Architecture
Heineman define software component as a
software element that conforms to a component model and can be independently deployed and composed without modification according to a composition standard.
Software components is a unit of composition. Software systems are build by composing different components.  Software components must conform to a component model by having contractually specified interfaces and explicit context dependencies only..
A component	interface defines a set of component functional properties, that is, a set of actions that’s understood by both the interface provider (the component) and user (other components, or other software that interacts with the provider).
A component interface has a role as a component specification and also a means for interaction between the component and its environment.
A component model is a set of standards for a component implementation. These standards can standardize naming, interoperability, customization, composition, evolution and deployment.
The component deployment is the process that enables component integration into the system. A deployed component is registered in the system and ready to provide services.
Component binding is the process that connects different components through their interfaces and interaction channels.
Software architecture deals with the definition of components, their external behavior, and how they interact.
Component based software engineering (CBSE) approach consists in building systems from components as reusable units and keeping component development separate from system development.
CBSE is built on the following four principles:
  Reusability. Components, developed once, have the potential for reuse many times in different applications.
  Substitutability. Systems maintain correctness even when one component replaces another.
  Extensibility. Extensibility aims to support evolution by adding new components or evolving existing ones to extend the system’s functionality.
  Composability. System should supports the composition of functional properties (component binding). Composition of extra functional properties, for example composition of components’ reliability, is another possible form of composition.
Goal-oriented requirements engineering
Goal-oriented requirements engineering (GORE) is concerned with the use of goals for eliciting, elaborating, structuring, specifying, analyzing, negotiating, documenting, and modifying requirements.
GORE models are the main tool used by system analysts and stakeholders to reason about the system requirements. Goal modeling represents a shift in relation to traditional software development approaches as it focus on stakeholder goals and states that the system needs to achieve and not in how it achieves it. Goal models are graphs representing AND/OR-decomposition of abstract goals down to operationalisable leaf-level goals. 
A goal is an objective the system under consideration should achieve. 
TROPOS
Tropos is a methodology for develop multi-agent systems that uses goal models for requirement analyses. Tropos encompasses the software development phases, from Early Requirements to Implementation and Testing.
The Tropos key concepts
The methodology adopts the i*  modeling framework, which proposes the concepts of actor, goal, task, resource and social dependency to model both the system-to-be and its organizational operating environment. In more recent publication  about the Tropos modeling framework the concept of task was renamed to plan.
The following are the key concepts in the Tropos metamodel:
    Actor: an entity that has strategic goals and intentionality
    Agent: physical manifestation of an actor.
    Goals: it represents actors’ strategic interests. Hard goals are goals that have clear-cut criteria for deciding whether they are satisfied or not. Softgoals have no clear-cut criteria and are normally used to describe preferences and quality-of-service demands.
    Plan: it represents, at an abstract level, a way of doing something. The execution of a plan can be a means for satisfying a goal or for satisficing (i.e. sufficiently satisfying) a softgoal.
    Resource: it represents a physical or an informational entity.
    Dependency: its a relationship between two actors that specify that one actor (the depended) have a dependency to other actor (the dependee) to attain some goal, execute some plan or deliver a resource. The object of the dependence is the dependum.
    Capability: it represents both the ability of an actor to perform some action and the opportunity of doing this.
    Belief: it represents actor knowledge of the world.
Multiagent systems (MAS)
Wooldridge  define Multiagent Systems (MAS) as systems composed of multiple interacting computing elements known as agents.
Agents are computer systems that are capable of autonomous action and interacting with other agents.
Proposal
Proposed Solution
We propose a component model for goal oriented multi-agent systems  and a runtime model that allows reason about the system levels of operation.
This model will be implemented by a middleware, that will keep the traceability between goals and architecture and allow for managing the architecture and implementing fault-tolerance in face of fault components at runtime.
Conceptual Model
Component Model
We propose and extension to Tropos Model with a component model. By this we aim at creating an appropriate abstraction to allow composable architecture while keeping the traceability between the requirements and implementation at runtime.
Or component model is build around the concept of strategy. The strategy at goal model level is a mean of achieving a particular goal. It can have the following realization at runtime:
  a strategy can be implemented by a component in the architecture.
  can be a delegation to another known agent as a runtime decision.
  can be a fault tolerant proxy that combines a implementation or delegation with a fault tolerance technique.
From a goal model, each goal will originate at least a capacity and strategy. Each OR decomposition of a goal, in the goal model, should correspond to an additional strategy.
An agent in the system has a repository of strategies.
The main concepts are:
  Agent: agent is an independent computational unit that manages its own resources (CPU, memory, disk, sensors, etc). After system deployment an agent is turned into an actor of a Tropos model.
  Capability: description of a kind of goal that an agent can perform. Its a component interface description in the architecture.
  Strategy: a strategy is an alternative way to achieve a goal.
  Strategy Repository: an agent has a repository of its known strategies.
A strategy should declare its functional interface by declaring which capability it implements. A strategy also needs to declare its dependencies as plans and capacities that it depends on. A strategy is active if all its dependencies are currently satisfied. It is inactive otherwise. A capability is satisfied if an agent has at least one active strategy that implement that capability.
Architectural Layers
For the implementation of the conceptual model, we propose an architecture of three layers:
  Infrastructure: This layer is responsible for the component model implementation, how capability, strategies, plans and goals instances are described. It also responsible for agent and goals life cycle, strategies management and selection.
  Adaptation: This layer is responsible for keep the level of service. It contains strategies to discover peers, team up with peers, gather information to improve strategy selection, etc.
  Application: This layer if responsible for functional strategies. The functional strategies are the one that implement user application.
Runtime Model
Dalpiaz et al.  argue that traditional goal models are not enough for reason about the system at runtime. They propose a distinction between Desgin-time Goal Model (DGM) and Runtime Goal Model (RGM). We extend their proposal of RGM with a component model and runtime strategy selection.
Goal Instance: an actual instance of an objective for a given data set.
Believe: is the model of an actor about itself and the context. Represents what the agent know.
Strategy Deployment: occurs after the strategy selection, is the the binding between the strategy, its capacities dependencies and its environment dependencies.
In the proposed model an actor achieve a goal by deploying a strategy and executing it. For instance the deployment of a strategy is a capability itself.
Strategy Selection and Deployment
In order to allow component based adaptation we propose a mechanist of strategy selection at runtime. This mechanism is part of the infrastructure layer. For a hight level of flexibility we propose that the selection mechanism itself should be implemented by components in the architecture.
At a low level an agent has the capability of fulfill goals. Inspired by component based frameworks like Rainbow we propose that the strategy should be chosen by means of a utility function. That utility function should be responsible to calculate which available strategy will have a better contribution for softgoals.
After a strategy is selected it is deployed. Strategy deployment corresponds to a component binding in CBSE.
The capacity <fulfill goal> and its corresponding strategy should be as follows:
<Fulfill Goals> the capability to fulfill generic goals.
<Fulfill Goals> strategy to fulfill goals by selecting available strategies and evaluating them with an utility function. Consists of 3 sub-goals:
  
    Find Matching Strategies
    Decide on Strategies
    Deploy the Selected Strategy
  
And the following three strategies implement the previous 3 capabilities.
  <Find Local Matching Strategies> accomplishes <Find Matching Strategies>
  returns the list of matching strategies. A matching strategy is any strategy that implements the goal interface.
  <Select a Strategy> accomplishes <Decide on Strategies>
  using a pre-configured utility function that analyses strategies metadata and select a strategy.
  <Deploy Strategy> accomplishes <Deploy the Selected Strategy>. Bind the components with the goal instance and dependencies.
Awareness
The agent have a model of that repository that it can use for reason about its capacities, strategies and plans. The agent is also able to manage its own repository.
Self-awareness is provided by a set of self-awareness strategies. Example of self-aware strategies are:
  <List Local Strategies>, how the agent can know it actual capabilities.
  <List Goal Instances>, how the agent can know it current intentions.
  <List Deployed Strategies>, how the agent can know it current running strategies.
Multi Agent Deployment
In order to support multi-agent deployments we will extend the conceptual model and create a set of strategies at the adaptation level. First, in the conceptual model, we propose a extension of the Tropos model concept of role.
A role, in runtime, will be associated with a set of capabilities. A role is interpreted also as responsibilities of an actor. So if an agent accepts a role it should keep active strategies to accomplish goals related to capabilities associated with its role.
We will call the state when an actor is satisfying all its assigned roles as satisfying actor.
The deployment is the process of assign all needed roles to available agents and moving them to a state of satisfying actors.
In order to allow a system to adapt to deployment variability we propose an actor verification strategy. With this strategy the actor should check if itself is currently a satisfying actor. If there is a capability that the agent is currently not satisfying it can use recovery strategies.
Recovery strategies could be:
  lookup for strategy in external strategy repository;
  redistribute roles with peers;
  lookup for a peer with the missing capability;
  restore resource availability;
  
Virtual Strategies
To extend the model with adaptation capabilities we propose Virtual Strategies (VS). VS are means of achieving a goal that is not by binding a component. We propose two kinds of VS:
  delegating strategies. VS that allow an agent to achieve a goal by delegating it to a peer agent. When a agent discover that a peer have some capacities it creates proxy strategies in its own repository that allow it to fulfill goals by delegating to the peer.
  fault tolerance strategies. VS that wrap other strategies in a fault tolerance scheme. Examples of possible fault tolerance strategies are active replication and retry.
The creation of virtual strategies will be performed by Virtual Strategy Producers (VSP) that are strategies in itself. The creation of a VSP is a Virtual Strategy Instance VSI.
A VSI has its own metadata and is evaluated by the utility function in the process of strategy selection.
 A VSP can reason about the context in order to adapt the strategy creation. So, for example, in a context that the agent needs to save battery, the active replication strategy may not be produced.
Related Work
Rainbow is a framework for self-adaptation architecture based. It keeps an model of the architecture of the system and can be extended with rules to analysis the system behavior at runtime, find adaptation strategies and perform this changes. It separate the functional code (internal mechanisms) from adaptation code (external mechanism) in a schema called external control, influenced by control theory. 
Different from our proposal it isn't goal-oriented an there is no work on how to relate Rainbow components to requirements.
MUSIC project provides a component-based middleware for adaptation that propose to separate the self-adaptation from business logic and delegate adaptation logic to generic middleware. As in our propose it adapts by evaluating in runtime the utility of alternatives, to chose a feasible one (e.g., the one evaluated as with highest utility). As Rainbow, MUSIC is not goal-oriented.
Salehie et al.  propose a run-time goal model and its related
action selection. It models adaptable software as a system that exposes sensors and effectors and  proposes a model consisting in Goals, Attributes and Action for selecting actions that will effect the adaptable software at runtime, giving sensed attributes.
So the adaptation mechanism is to choose the best action given the actual attributes.
As this work it uses explicit runtime goals and make them visible and traceable.
Different from it we use a more symmetric approach that can allow for functional
and adaptation management.
Günalp et al.  propose a middleware for pervasive software with autonomic capabilities. The approach is service based. It proposes a component written in a custom language and the use of components repository that allows the discovery on new sensors. The system present a support for adaptability by using policies.
Pinto et al.  introduces a approach to support traceability through requirements specifications, system architecture models, static and dynamic software design models and implementation artifacts of agent-oriented software systems.
The authors use a set of types of relationships and structure the traceable information in levels (external, organizational and management) to improve the semantic of requirement traceability.
The work also includes a process to be followed during the development of the traceability model
Methodology
In this section we will describe our methodology. At a hight level our main activities will be: review the literature, elaborate a conceptual model, implement and evaluate a middleware, write the dissertation, write paper and viva presentation.
The implementation will be divided in 2 phases so we can submit intermediate results to scientific conferences.



literature review

First we will conduct a literature review with the objective to find all the relevant related works, what is the state of the art, review that works and better proposition our proposal in relation to that works.

elaborate a conceptual model and architecture

In parallel to the literature review, we will develop a conceptual model to integrate Goal-Oriented Requirements Engineering, Architecture-Based Self-Adaptation so that the system goals can be traced to architecture modules at runtime. This conceptual-model will describe the Architectural components of the proposed architecture, their relations, how this elements are related to the goal model that they implement and how this model can be manipulated at runtime.


implement and validate a middleware (Core)

At this stage we will implement the core of a middleware to support execution of components as described by the proposed conceptual model and evaluate. To do the evaluation we will specify and describe a study case system and implement the system using the middleware and the proposed architecture.

write paper about the middleware (Core)

We will report the results of the middleware implementation and validation as a paper.




 

implement and validate dependability strategies

 implement and evaluate GODA strategy for runtime dependability analysis at runtime.

 write paper about dependability strategies

 We will report the results of the middleware implementation and validation as a paper.

write up dissertation

gather all intermediate results and format as a dissertation.

viva

present the dissertation.


Expected Results
Expected Results
With this work we expect to:
Collaborate to self-adaptation corpus of knowledge by contributing with a conceptual model that maps concepts of Goal-Model and Architecture-based adaptation.
Generate a proposal of architecture and reference middleware for development of applications that face a high level of context variation and couple this uncertainty by reasoning about its goal model at runtime.
By the former two items, we expect to allow for future development of more flexible and dependable and adaptable software system.
Chronogram
The proposed work is composed of the following activities:


literature review
elaborate a conceptual model
implement and validate a middleware (Core)
write paper about the middleware (Core)
implement and validate dependability strategies
 write paper about dependability strategies
write up dissertation
viva





plain
